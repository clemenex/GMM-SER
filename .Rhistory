"Posterior difference shows higher pitch_sd in expressive group",
"Pitch_sd successfully captures interpretable emotional variation",
"Gaussian Mixture Model (GMM)",
"Unsupervised discovery of latent emotional profiles via pitch_sd",
"μ1 = 542.6, μ2 = 866.2; θ1 = 6%, θ2 = 94%",
"Latent emotional states can be recovered directly from prosodic variation"
)
kable(comparison_tbl, caption = "Comparison of Models for Pitch_SD Emotional Profiling")
library(tibble)
library(knitr)
objective_metrics_tbl <- tribble(
~Model, ~Metric, ~Value, ~Interpretation,
# Random Intercept Model
"Random Intercept (LMM)", "Residual Variance (σ)", "81.4 (60s), 110.0 (30s)",
"60s has lower within-subject noise → more stable prosodic signal",
"Random Intercept (LMM)", "Group Variance (sd(Intercept))", "104.5 (60s), 102.9 (30s)",
"Between-subject variability is consistent across window sizes",
# BEST Model
"BEST (Bayesian t-test)", "Posterior Difference (Expressive - Flat)", "> 0",
"Strong support that expressive speakers have higher pitch variation",
"BEST (Bayesian t-test)", "95% Credible Interval", "Excludes 0",
"Statistically significant separation between affect groups",
# Mixture Model
"Mixture Model (2-class)", "μ1 / μ2", "542.6 / 866.2",
"Latent flat vs expressive affect profiles discovered",
"Mixture Model (2-class)", "θ1 / θ2", "6% / 94%",
"Majority of windows assigned to expressive class",
"Mixture Model (2-class)", "Credible Interval Overlap", "None (μ1 and μ2)",
"Posterior separation supports real emotional clusters"
)
kable(objective_metrics_tbl, caption = "Objective Metrics for Pitch_SD Models")
library(brms)
library(tibble)
library(knitr)
# 1. Extract values from Random Intercept model
lmm_summary <- summary(pitch_sd_model)
sigma_lmm <- round(lmm_summary$spec_pars["sigma", "Estimate"], 1)
group_sd <- round(lmm_summary$random$participant_id["sd(Intercept)", "Estimate"], 1)
lmm_mean <- round(lmm_summary$fixed["Intercept", "Estimate"], 1)
# 2. Extract from BEST model
best_summary <- summary(best_model)
best_diff <- round(best_summary$fixed[1, "Estimate"] - best_summary$fixed[2, "Estimate"], 1)
best_ci <- paste0("[", round(best_summary$fixed[1, "l-95% CI"] - best_summary$fixed[2, "u-95% CI"], 1), ", ",
round(best_summary$fixed[1, "u-95% CI"] - best_summary$fixed[2, "l-95% CI"], 1), "]")
# 3. Extract from Mixture Model
mix_summary <- summary(mix_model_2)
mu1 <- round(mix_summary$fixed["mu1_Intercept", "Estimate"], 1)
mu2 <- round(mix_summary$fixed["mu2_Intercept", "Estimate"], 1)
theta1 <- round(mix_summary$spec_pars["theta1", "Estimate"] * 100, 1)
theta2 <- round(mix_summary$spec_pars["theta2", "Estimate"] * 100, 1)
mu_ci_overlap <- ifelse(mix_summary$fixed["mu1_Intercept", "u-95% CI"] <
mix_summary$fixed["mu2_Intercept", "l-95% CI"], "None", "Overlap")
# 4. Construct the table
objective_tbl <- tribble(
~Model, ~Metric, ~Value, ~Interpretation,
# LMM
"Random Intercept (LMM)", "Mean pitch_sd", lmm_mean,
"Average pitch variability across participants (60s window)",
"Random Intercept (LMM)", "Residual Variance (σ)", sigma_lmm,
"Within-participant noise; lower = more stable measurement",
"Random Intercept (LMM)", "Group Variance (sd(Intercept))", group_sd,
"Between-participant variability in emotional signal",
# BEST
"BEST (Bayesian t-test)", "Posterior Difference (Exp - Flat)", best_diff,
"Effect size between expressive and flat affect groups",
"BEST (Bayesian t-test)", "95% CI of Difference", best_ci,
"Credible interval for group separation",
# Mixture
"Gaussian Mixture Model", "μ1 / μ2", paste(mu1, "/", mu2),
"Means of low vs expressive clusters (non-overlapping)",
"Gaussian Mixture Model", "Cluster Proportion (θ1 / θ2)", paste0(theta1, "% / ", theta2, "%"),
"Cluster size distribution: flat vs expressive affect",
"Gaussian Mixture Model", "CI Overlap (μ1 vs μ2)", mu_ci_overlap,
"Indicates if the two latent classes are statistically distinct"
)
library(brms)
library(tibble)
library(knitr)
# 1. Extract values from Random Intercept model
lmm_summary <- summary(pitch_sd_model)
sigma_lmm <- round(lmm_summary$spec_pars["sigma", "Estimate"], 1)
group_sd <- round(lmm_summary$random$participant_id["sd(Intercept)", "Estimate"], 1)
lmm_mean <- round(lmm_summary$fixed["Intercept", "Estimate"], 1)
# 2. Extract from BEST model
best_summary <- summary(best_model)
best_diff <- round(best_summary$fixed[1, "Estimate"] - best_summary$fixed[2, "Estimate"], 1)
best_ci <- paste0("[", round(best_summary$fixed[1, "l-95% CI"] - best_summary$fixed[2, "u-95% CI"], 1), ", ",
round(best_summary$fixed[1, "u-95% CI"] - best_summary$fixed[2, "l-95% CI"], 1), "]")
# 3. Extract from Mixture Model
mix_summary <- summary(mix_model_2)
mu1 <- round(mix_summary$fixed["mu1_Intercept", "Estimate"], 1)
mu2 <- round(mix_summary$fixed["mu2_Intercept", "Estimate"], 1)
theta1 <- round(mix_summary$spec_pars["theta1", "Estimate"] * 100, 1)
theta2 <- round(mix_summary$spec_pars["theta2", "Estimate"] * 100, 1)
mu_ci_overlap <- ifelse(mix_summary$fixed["mu1_Intercept", "u-95% CI"] <
mix_summary$fixed["mu2_Intercept", "l-95% CI"], "None", "Overlap")
# 4. Construct the table
objective_tbl <- tribble(
~Model, ~Metric, ~Value, ~Interpretation,
# LMM
"Random Intercept (LMM)", "Mean pitch_sd", as.character(lmm_mean),
"Average pitch variability across participants (60s window)",
"Random Intercept (LMM)", "Residual Variance (σ)", as.character(sigma_lmm),
"Within-participant noise; lower = more stable measurement",
"Random Intercept (LMM)", "Group Variance (sd(Intercept))", as.character(group_sd),
"Between-participant variability in emotional signal",
# BEST
"BEST (Bayesian t-test)", "Posterior Difference (Exp - Flat)", as.character(best_diff),
"Effect size between expressive and flat affect groups",
"BEST (Bayesian t-test)", "95% CI of Difference", best_ci,
"Credible interval for group separation",
# Mixture
"Gaussian Mixture Model", "μ1 / μ2", paste(mu1, "/", mu2),
"Means of low vs expressive clusters (non-overlapping)",
"Gaussian Mixture Model", "Cluster Proportion (θ1 / θ2)", paste0(theta1, "% / ", theta2, "%"),
"Cluster size distribution: flat vs expressive affect",
"Gaussian Mixture Model", "CI Overlap (μ1 vs μ2)", mu_ci_overlap,
"Indicates if the two latent classes are statistically distinct"
)
kable(objective_tbl, caption = "Objectively Extracted Metrics from All Pitch_SD Models")
library(brms)
library(tibble)
library(knitr)
# 1. Extract values from Random Intercept model
lmm_summary <- summary(pitch_sd_model)
sigma_lmm <- round(lmm_summary$spec_pars["sigma", "Estimate"], 1)
group_sd <- round(lmm_summary$random$participant_id["sd(Intercept)", "Estimate"], 1)
lmm_mean <- round(lmm_summary$fixed["Intercept", "Estimate"], 1)
# 2. Extract from BEST model
best_summary <- summary(best_model)
best_diff <- round(best_summary$fixed[1, "Estimate"] - best_summary$fixed[2, "Estimate"], 1)
best_ci <- paste0("[", round(best_summary$fixed[1, "l-95% CI"] - best_summary$fixed[2, "u-95% CI"], 1), ", ",
round(best_summary$fixed[1, "u-95% CI"] - best_summary$fixed[2, "l-95% CI"], 1), "]")
# 3. Extract from Mixture Model
mix_summary <- summary(mix_model_2)
mu1 <- round(mix_summary$fixed["mu1_Intercept", "Estimate"], 1)
mu2 <- round(mix_summary$fixed["mu2_Intercept", "Estimate"], 1)
theta1 <- round(mix_summary$spec_pars["theta1", "Estimate"] * 100, 1)
theta2 <- round(mix_summary$spec_pars["theta2", "Estimate"] * 100, 1)
mu_ci_overlap <- ifelse(mix_summary$fixed["mu1_Intercept", "u-95% CI"] <
mix_summary$fixed["mu2_Intercept", "l-95% CI"], "None", "Overlap")
# 4. Construct the table
objective_tbl <- tribble(
~Model, ~Metric, ~Value, ~Interpretation,
# LMM
"Random Intercept (LMM)", "Mean pitch_sd", as.character(lmm_mean),
"Average pitch variability across participants (60s window)",
"Random Intercept (LMM)", "Residual Variance (σ)", as.character(sigma_lmm),
"Within-participant noise; lower = more stable measurement",
"Random Intercept (LMM)", "Group Variance (sd(Intercept))", as.character(group_sd),
"Between-participant variability in emotional signal",
# BEST
"BEST (Bayesian t-test)", "Posterior Difference (Exp - Flat)", as.character(best_diff),
"Effect size between expressive and flat affect groups",
"BEST (Bayesian t-test)", "95% CI of Difference", best_ci,
"Credible interval for group separation",
# Mixture
"Gaussian Mixture Model", "μ1 / μ2", paste(mu1, "/", mu2),
"Means of low vs expressive clusters (non-overlapping)",
"Gaussian Mixture Model", "Cluster Proportion (θ1 / θ2)", paste0(theta1, "% / ", theta2, "%"),
"Cluster size distribution: flat vs expressive affect",
"Gaussian Mixture Model", "CI Overlap (μ1 vs μ2)", mu_ci_overlap,
"Indicates if the two latent classes are statistically distinct"
)
kable(objective_tbl, caption = "Objective Metrics from All Pitch_SD Models")
library(brms)
library(tibble)
library(knitr)
# 1. Extract values from Random Intercept model
lmm_summary <- summary(pitch_sd_model)
sigma_lmm <- round(lmm_summary$spec_pars["sigma", "Estimate"], 1)
group_sd <- round(lmm_summary$random$participant_id["sd(Intercept)", "Estimate"], 1)
lmm_mean <- round(lmm_summary$fixed["Intercept", "Estimate"], 1)
# 2. Extract from BEST model
best_summary <- summary(best_model)
best_diff <- round(best_summary$fixed[1, "Estimate"] - best_summary$fixed[2, "Estimate"], 1)
best_ci <- paste0("[", round(best_summary$fixed[1, "l-95% CI"] - best_summary$fixed[2, "u-95% CI"], 1), ", ",
round(best_summary$fixed[1, "u-95% CI"] - best_summary$fixed[2, "l-95% CI"], 1), "]")
# 3. Extract from Mixture Model
mix_summary <- summary(mix_model_2)
mu1 <- round(mix_summary$fixed["mu1_Intercept", "Estimate"], 1)
mu2 <- round(mix_summary$fixed["mu2_Intercept", "Estimate"], 1)
theta1 <- round(mix_summary$spec_pars["theta1", "Estimate"] * 100, 1)
theta2 <- round(mix_summary$spec_pars["theta2", "Estimate"] * 100, 1)
mu_ci_overlap <- ifelse(mix_summary$fixed["mu1_Intercept", "u-95% CI"] <
mix_summary$fixed["mu2_Intercept", "l-95% CI"], "None", "Overlap")
# 4. Construct the table
objective_tbl <- tribble(
~Model, ~Metric, ~Value, ~Interpretation,
# LMM
"Random Intercept (LMM)", "Mean pitch_sd", as.character(lmm_mean),
"Average pitch variability across participants (60s window)",
"Random Intercept (LMM)", "Residual Variance (σ)", as.character(sigma_lmm),
"Within-participant noise; lower = more stable measurement",
"Random Intercept (LMM)", "Group Variance (sd(Intercept))", as.character(group_sd),
"Between-participant variability in emotional signal",
# BEST
"BEST (Bayesian t-test)", "Posterior Difference (Exp - Flat)", as.character(best_diff),
"Effect size between expressive and flat affect groups",
"BEST (Bayesian t-test)", "95% CI of Difference", best_ci,
"Credible interval for group separation",
# Mixture
"Gaussian Mixture Model", "μ1 / μ2", paste(mu1, "/", mu2),
"Means of low vs expressive clusters (non-overlapping)",
"Gaussian Mixture Model", "Cluster Proportion (θ1 / θ2)", paste0(theta1, "% / ", theta2, "%"),
"Cluster size distribution: flat vs expressive affect",
"Gaussian Mixture Model", "CI Overlap (μ1 vs μ2)", mu_ci_overlap,
"Indicates if the two latent classes are statistically distinct"
)
kable(objective_tbl, caption = "Objective Metrics from Across Models")
library(brms)
library(tibble)
library(knitr)
# 1. Extract from Random Intercept model
lmm_summary <- summary(pitch_sd_model)
sigma_lmm <- round(lmm_summary$spec_pars["sigma", "Estimate"], 1)
group_sd <- round(lmm_summary$random$participant_id["sd(Intercept)", "Estimate"], 1)
lmm_mean <- round(lmm_summary$fixed["Intercept", "Estimate"], 1)
# 2. Extract from BEST model
best_summary <- summary(best_model)
best_diff <- round(best_summary$fixed[1, "Estimate"] - best_summary$fixed[2, "Estimate"], 1)
best_ci <- paste0("[", round(best_summary$fixed[1, "l-95% CI"] - best_summary$fixed[2, "u-95% CI"], 1), ", ",
round(best_summary$fixed[1, "u-95% CI"] - best_summary$fixed[2, "l-95% CI"], 1), "]")
# 3. Extract from Mixture Model
mix_summary <- summary(mix_model_2)
mu1 <- round(mix_summary$fixed["mu1_Intercept", "Estimate"], 1)
mu2 <- round(mix_summary$fixed["mu2_Intercept", "Estimate"], 1)
theta1 <- round(mix_summary$spec_pars["theta1", "Estimate"] * 100, 1)
theta2 <- round(mix_summary$spec_pars["theta2", "Estimate"] * 100, 1)
mu_ci_overlap <- ifelse(mix_summary$fixed["mu1_Intercept", "u-95% CI"] <
mix_summary$fixed["mu2_Intercept", "l-95% CI"], "None", "Overlap")
# 4. Build the trimmed table
metrics_tbl <- tribble(
~Model, ~Metric, ~Value,
# LMM
"Random Intercept (LMM)", "Mean pitch_sd", as.character(lmm_mean),
"Random Intercept (LMM)", "Residual Variance (σ)", as.character(sigma_lmm),
"Random Intercept (LMM)", "Group Variance (sd(Intercept))", as.character(group_sd),
# BEST
"BEST (Bayesian t-test)", "Posterior Difference (Exp - Flat)", as.character(best_diff),
"BEST (Bayesian t-test)", "95% CI of Difference", best_ci,
# Mixture
"Gaussian Mixture Model", "μ1 / μ2", paste(mu1, "/", mu2),
"Gaussian Mixture Model", "Cluster Proportion (θ1 / θ2)", paste0(theta1, "% / ", theta2, "%"),
"Gaussian Mixture Model", "CI Overlap (μ1 vs μ2)", mu_ci_overlap
)
kable(metrics_tbl, caption = "Objective Metrics Across Models")
getwd()
setwd("~/coursera-r")
getwd()
setwd("~/coursera-r")
getwd()
library(XML)
library(RC)
library(RCurl)
url <- "http://scholar.google.com/citations?user=HI-I60AAAAJ&hl=en"
html <- htmlTreeParse(url, useInternalNodes = TRUE)
page  <- getURL(url)
doc   <- htmlParse(page, asText = TRUE)
title <- xpathSApply(doc, "//title", xmlValue)
print(title)
install.packages("httr")
library(httr); html2 = GET(url)
content2 = content(html2,as="text")
parsedHtml = htmlParse(content2,asText=TRUE)
xpathSApply(parsedHtml, "//title", xmlValue)
pg2 = GET("http://httpbin.org/basic-auth/user/passwd",
authenticate("user","passwd"))
pg2
names(pg2)
google = handle("http://google.com")
pg1 = GET(handle=google,path="/")
pg2 = GET(handle=google,path="search")
pg1
pg2
getwd()
setwd("~/coursera-r/ProgrammingAssignment2")
getwd()
source("cachematrix.R")
cm <- makeCacheMatrix(matrix(c(2, 0, 0, 2), nrow = 2))
inv1 <- cacheSolve(cm)
inv2 <- cacheSolve(cm)
cm$set(matrix(c(1,2,3,4), 2, 2))
inv3 <- cacheSolve(cm)
set.seed(1)
rpois(5, 2)
getwd()
setwd("~/coursera-r/ProgrammingAssignment3")
outcome <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
outcome <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
outcome[, 11] <- suppressWarnings(as.numeric(outcome[, 11]))
hist(outcome[, 11],
main = "30-Day Mortality Rates from Heart Attack",
xlab = "30-Day Death Rate",
col  = "lightblue",
breaks = 20)
best("TX", "heart attack")
source("best.R")
best("TX", "heart attack")
source("rankhospital.R")
rankhospital("TX", "heart failure", 4)
source("rankall.R")
source("rankall.R")
head(rankall("heart attack", 20), 10)
best("SC", "heart attack")
best("NY", "pneumonia")
best("AK", "pneumonia")
rankhospital("NC", "heart attack", "worst")
rankhospital("WA", "heart attack", 7)
rankhospital("TX", "pneumonia", 10)
rankhospital("NY", "heart attack", 7)
r <- rankall("heart attack", 4)
as.character(subset(r, state == "HI")$hospital)
r <- rankall("pneumonia", "worst")
as.character(subset(r, state == "NJ")$hospital)
r <- rankall("heart failure", 10)
as.character(subset(r, state == "NV")$hospital)
swirl()
library(swirl)
swirl()
install_from_swirl("Getting and Cleaning Data")
swirl()
setwd("~/coursera-r/Getting and Cleaning Data")
getwd()
download.file(url)
url <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv"
download.file(url, "getdata_data_ss06hid.csv")
df <- read.csv("ss06hid.csv", stringsAsFactors = FALSE)
df <- read.csv("getdata_data_ss06hid.csv", stringsAsFactors = FALSE)
sum(df$VAL == 24, na.rm = TRUE)
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FDATA.gov_NGAP.xlsx"
download.file(fileUrl, destfile = "NGAP.xlsx", mode = "wb")
install.packages("xlsx")
library(xlsx)
dat <- read.xlsx(
file          = "NGAP.xlsx",
sheetIndex    = 1,
colIndex      = 7:15,
rowIndex      = 18:23
)
sum(dat$Zip*dat$Ext,na.rm=T)
library(XML)
# Parse the XML directly from the URL
url <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Frestaurants.xml"
doc <- xmlTreeParse(url, useInternalNodes = TRUE)
setwd("~/coursera-r/Getting and Cleaning Data/course project")
getwd()
# This script performs the following steps on the UCI HAR Dataset:
# 1. Merges the training and the test sets to create one data set.
# 2. Extracts only the measurements on the mean and standard deviation for each measurement.
# 3. Uses descriptive activity names to name the activities in the data set.
# 4. Appropriately labels the data set with descriptive variable names.
# 5. Creates a second, independent tidy data set with the average of each variable for each activity and each subject.
install.packages("dplyr")
library(dplyr)
# READ DATA
features <- read.table("UCI HAR Dataset/features.txt", col.names = c("index", "feature"))
setwd("~/coursera-r/Getting and Cleaning Data/course project/getting-and-cleaning-data-project")
#Getting and Cleaning Data Course Project
#Made by Clemenex
# This script performs the following steps on the UCI HAR Dataset:
# 1. Merges the training and the test sets to create one data set.
# 2. Extracts only the measurements on the mean and standard deviation for each measurement.
# 3. Uses descriptive activity names to name the activities in the data set.
# 4. Appropriately labels the data set with descriptive variable names.
# 5. Creates a second, independent tidy data set with the average of each variable for each activity and each subject.
install.packages("dplyr")
library(dplyr)
# READ DATA
features <- read.table("UCI HAR Dataset/features.txt", col.names = c("index", "feature"))
activity_labels <- read.table("UCI HAR Dataset/activity_labels.txt", col.names = c("activityID", "activity"))
# 2. LOAD DATA & LABEL TRAIN DATA
subject_train <- read.table("UCI HAR Dataset/train/subject_train.txt", col.names = "subject")
y_train <- read.table("UCI HAR Dataset/train/y_train.txt", col.names = "activityID")
X_train <- read.table("UCI HAR Dataset/train/X_train.txt", col.names = features$feature)
#Getting and Cleaning Data Course Project
#Made by Clemenex
# This script performs the following steps on the UCI HAR Dataset:
# 1. Merges the training and the test sets to create one data set.
# 2. Extracts only the measurements on the mean and standard deviation for each measurement.
# 3. Uses descriptive activity names to name the activities in the data set.
# 4. Appropriately labels the data set with descriptive variable names.
# 5. Creates a second, independent tidy data set with the average of each variable for each activity and each subject.
library(dplyr)
# READ DATA
features <- read.table("UCI HAR Dataset/features.txt", col.names = c("index", "feature"))
activity_labels <- read.table("UCI HAR Dataset/activity_labels.txt", col.names = c("activityID", "activity"))
# 2. LOAD DATA & LABEL TRAIN DATA
subject_train <- read.table("UCI HAR Dataset/train/subject_train.txt", col.names = "subject")
y_train <- read.table("UCI HAR Dataset/train/y_train.txt", col.names = "activityID")
X_train <- read.table("UCI HAR Dataset/train/X_train.txt", col.names = features$feature)
# 3. LOAD DATA & LABEL TEST DATA
subject_test <- read.table("UCI HAR Dataset/test/subject_test.txt", col.names = "subject")
y_test <- read.table("UCI HAR Dataset/test/y_test.txt", col.names = "activityID")
X_test <- read.table("UCI HAR Dataset/test/X_test.txt", col.names = features$feature)
# 4. DATA MERGING
train_data <- cbind(subject_train, y_train, X_train)
test_data  <- cbind(subject_test,  y_test,  X_test)
full_data  <- rbind(train_data, test_data)
# 5. GET MEAN AND SD
mean_std_features <- grep("mean\\(\\)|std\\(\\)", features$feature)
selected_names <- features$feature[mean_std_features]
selected_data <- full_data %>% select(subject, activityID, all_of(selected_names))
#Getting and Cleaning Data Course Project
#Made by Clemenex
# This script performs the following steps on the UCI HAR Dataset:
# 1. Merges the training and the test sets to create one data set.
# 2. Extracts only the measurements on the mean and standard deviation for each measurement.
# 3. Uses descriptive activity names to name the activities in the data set.
# 4. Appropriately labels the data set with descriptive variable names.
# 5. Creates a second, independent tidy data set with the average of each variable for each activity and each subject.
library(dplyr)
# READ DATA
features <- read.table("UCI HAR Dataset/features.txt", col.names = c("index", "feature"))
activity_labels <- read.table("UCI HAR Dataset/activity_labels.txt", col.names = c("activityID", "activity"))
mean_std_indices <- grep("mean\\(\\)|std\\(\\)", features$feature)
selected_features <- features$feature[mean_std_indices]
# LOADING DATA
load_data <- function(type) {
subject <- read.table(file.path("UCI HAR Dataset", type, paste0("subject_", type, ".txt")), col.names = "subject")
y <- read.table(file.path("UCI HAR Dataset", type, paste0("y_", type, ".txt")), col.names = "activityID")
X <- read.table(file.path("UCI HAR Dataset", type, paste0("X_", type, ".txt")), col.names = features$feature, check.names = FALSE)
data <- cbind(subject, y, X)
# Keep only subject, activityID, and mean/std measurements
data[, c("subject", "activityID", selected_features)]
}
# LOADING AND MERGING TRAIN & TEST DATA
train_data <- load_data("train")
test_data  <- load_data("test")
full_data  <- rbind(train_data, test_data)
# TIDYING DATA
tidy_data <- full_data %>%
left_join(activity_labels, by = "activityID") %>%
select(-activityID)
# LABELLING TIDY DATA
clean_names <- names(tidy_data) %>%
gsub("\\()", "",          .) %>%
gsub("^t",     "time",      .) %>%
gsub("^f",     "frequency", .) %>%
gsub("Acc",    "Accelerometer", .) %>%
gsub("Gyro",   "Gyroscope",     .) %>%
gsub("Mag",    "Magnitude",     .) %>%
gsub("BodyBody", "Body",        .) %>%
gsub("-mean",  "Mean",         .) %>%
gsub("-std",   "Std",          .) %>%
gsub("-",      "",             .)
names(tidy_data) <- clean_names
# TIDY DATA
final_tidy <- tidy_data %>%
group_by(subject, activity) %>%
summarise(across(everything(), mean), .groups = "drop")
# SAVING DATA
write.table(final_tidy, "tidy_dataset.txt", row.names = FALSE, quote = FALSE)
View(final_tidy)
my_list <- list(Name = "Alice", Age = 25, Scores = c(90, 85, 88))
my_list[["Scores"]][2]
mat <- matrix(1:6, nrow=2, ncol=3)
mat[1, 3]
mat
str(attributes)
?attributes
v <- 1:3
names(v) <- c("a", "b", "c")
v[4] <-4
v[4]
setwd("~/")
getwd()
library(tidyverse)
library(brms)
library(tidybayes)
library(bayesplot)
library(here)
library(knitr)
# Load the data
df <- read_csv("data/daic_prosodic_summary_60s.csv") %>%
mutate(
participant_id = factor(participant_id),
window = factor(window)
)
pitch_sd_model <- brm(
pitch_sd ~ 1 + (1 | participant_id),
data = df,
family = gaussian(),
chains = 4,
iter = 4000,
warmup = 1000,
cores = parallel::detectCores(),
control = list(adapt_delta = 0.95),
seed = 123
)
plot(pitch_sd_model)
pp_check(pitch_sd_model)
summary(pitch_sd_model)
ranef(pitch_sd_model)$participant_id %>%
as.data.frame() %>%
arrange(desc(Estimate.Intercept)) %>%
head(10) %>%
knitr::kable(
digits = 3,
caption = "Top 10 Participants by Pitch Variation (Random Effects)"
)
energy_sd_model <- brm(
energy_sd ~ 1 + (1 | participant_id),
data = df,
family = gaussian(),
chains = 4,
iter = 4000,
warmup = 1000,
cores = parallel::detectCores(),
control = list(adapt_delta = 0.95),
seed = 123
)
